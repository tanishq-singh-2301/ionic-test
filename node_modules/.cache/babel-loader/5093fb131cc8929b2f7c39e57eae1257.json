{"ast":null,"code":"import _regeneratorRuntime from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nvar _getEffectiveRequest = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var request, mode, _ref$plugins, plugins, cacheKeyWillBeUsedPlugins, effectiveRequest, _iterator, _step, plugin;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            request = _ref.request, mode = _ref.mode, _ref$plugins = _ref.plugins, plugins = _ref$plugins === void 0 ? [] : _ref$plugins;\n            cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\"\n            /* CACHE_KEY_WILL_BE_USED */\n            );\n            effectiveRequest = request;\n            _iterator = _createForOfIteratorHelper(cacheKeyWillBeUsedPlugins);\n            _context.prev = 4;\n\n            _iterator.s();\n\n          case 6:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 15;\n              break;\n            }\n\n            plugin = _step.value;\n            _context.next = 10;\n            return plugin[\"cacheKeyWillBeUsed\"\n            /* CACHE_KEY_WILL_BE_USED */\n            ].call(plugin, {\n              mode: mode,\n              request: effectiveRequest\n            });\n\n          case 10:\n            effectiveRequest = _context.sent;\n\n            if (typeof effectiveRequest === 'string') {\n              effectiveRequest = new Request(effectiveRequest);\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\"\n                /* CACHE_KEY_WILL_BE_USED */\n                ,\n                isReturnValueProblem: true\n              });\n            }\n\n          case 13:\n            _context.next = 6;\n            break;\n\n          case 15:\n            _context.next = 20;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](4);\n\n            _iterator.e(_context.t0);\n\n          case 20:\n            _context.prev = 20;\n\n            _iterator.f();\n\n            return _context.finish(20);\n\n          case 23:\n            return _context.abrupt(\"return\", effectiveRequest);\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 17, 20, 23]]);\n  }));\n\n  return function _getEffectiveRequest(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nvar _isResponseSafeToCache = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {\n    var request, response, event, _ref3$plugins, plugins, responseToCache, pluginsUsed, _iterator2, _step2, plugin, pluginMethod;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            request = _ref3.request, response = _ref3.response, event = _ref3.event, _ref3$plugins = _ref3.plugins, plugins = _ref3$plugins === void 0 ? [] : _ref3$plugins;\n            responseToCache = response;\n            pluginsUsed = false;\n            _iterator2 = _createForOfIteratorHelper(plugins);\n            _context2.prev = 4;\n\n            _iterator2.s();\n\n          case 6:\n            if ((_step2 = _iterator2.n()).done) {\n              _context2.next = 19;\n              break;\n            }\n\n            plugin = _step2.value;\n\n            if (!(\"cacheWillUpdate\"\n            /* CACHE_WILL_UPDATE */\n            in plugin)) {\n              _context2.next = 17;\n              break;\n            }\n\n            pluginsUsed = true;\n            pluginMethod = plugin[\"cacheWillUpdate\"\n            /* CACHE_WILL_UPDATE */\n            ];\n            _context2.next = 13;\n            return pluginMethod.call(plugin, {\n              request: request,\n              response: responseToCache,\n              event: event\n            });\n\n          case 13:\n            responseToCache = _context2.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (responseToCache) {\n                assert.isInstance(responseToCache, Response, {\n                  moduleName: 'Plugin',\n                  funcName: \"cacheWillUpdate\"\n                  /* CACHE_WILL_UPDATE */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n            if (responseToCache) {\n              _context2.next = 17;\n              break;\n            }\n\n            return _context2.abrupt(\"break\", 19);\n\n          case 17:\n            _context2.next = 6;\n            break;\n\n          case 19:\n            _context2.next = 24;\n            break;\n\n          case 21:\n            _context2.prev = 21;\n            _context2.t0 = _context2[\"catch\"](4);\n\n            _iterator2.e(_context2.t0);\n\n          case 24:\n            _context2.prev = 24;\n\n            _iterator2.f();\n\n            return _context2.finish(24);\n\n          case 27:\n            if (!pluginsUsed) {\n              if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                  if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                      logger.warn(\"The response for '\".concat(request.url, \"' is an opaque \") + \"response. The caching strategy that you're using will not \" + \"cache opaque responses by default.\");\n                    } else {\n                      logger.debug(\"The response for '\".concat(request.url, \"' returned \") + \"a status code of '\".concat(response.status, \"' and won't be cached as a \") + \"result.\");\n                    }\n                  }\n                }\n              }\n\n              responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n            }\n\n            return _context2.abrupt(\"return\", responseToCache ? responseToCache : null);\n\n          case 29:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[4, 21, 24, 27]]);\n  }));\n\n  return function _isResponseSafeToCache(_x2) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nvar matchWrapper = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {\n    var cacheName, request, event, matchOptions, _ref5$plugins, plugins, cache, effectiveRequest, cachedResponse, _iterator3, _step3, plugin, pluginMethod;\n\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            cacheName = _ref5.cacheName, request = _ref5.request, event = _ref5.event, matchOptions = _ref5.matchOptions, _ref5$plugins = _ref5.plugins, plugins = _ref5$plugins === void 0 ? [] : _ref5$plugins;\n            _context3.next = 3;\n            return self.caches.open(cacheName);\n\n          case 3:\n            cache = _context3.sent;\n            _context3.next = 6;\n            return _getEffectiveRequest({\n              plugins: plugins,\n              request: request,\n              mode: 'read'\n            });\n\n          case 6:\n            effectiveRequest = _context3.sent;\n            _context3.next = 9;\n            return cache.match(effectiveRequest, matchOptions);\n\n          case 9:\n            cachedResponse = _context3.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (cachedResponse) {\n                logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n              } else {\n                logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n              }\n            }\n\n            _iterator3 = _createForOfIteratorHelper(plugins);\n            _context3.prev = 12;\n\n            _iterator3.s();\n\n          case 14:\n            if ((_step3 = _iterator3.n()).done) {\n              _context3.next = 24;\n              break;\n            }\n\n            plugin = _step3.value;\n\n            if (!(\"cachedResponseWillBeUsed\"\n            /* CACHED_RESPONSE_WILL_BE_USED */\n            in plugin)) {\n              _context3.next = 22;\n              break;\n            }\n\n            pluginMethod = plugin[\"cachedResponseWillBeUsed\"\n            /* CACHED_RESPONSE_WILL_BE_USED */\n            ];\n            _context3.next = 20;\n            return pluginMethod.call(plugin, {\n              cacheName: cacheName,\n              event: event,\n              matchOptions: matchOptions,\n              cachedResponse: cachedResponse,\n              request: effectiveRequest\n            });\n\n          case 20:\n            cachedResponse = _context3.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (cachedResponse) {\n                assert.isInstance(cachedResponse, Response, {\n                  moduleName: 'Plugin',\n                  funcName: \"cachedResponseWillBeUsed\"\n                  /* CACHED_RESPONSE_WILL_BE_USED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 22:\n            _context3.next = 14;\n            break;\n\n          case 24:\n            _context3.next = 29;\n            break;\n\n          case 26:\n            _context3.prev = 26;\n            _context3.t0 = _context3[\"catch\"](12);\n\n            _iterator3.e(_context3.t0);\n\n          case 29:\n            _context3.prev = 29;\n\n            _iterator3.f();\n\n            return _context3.finish(29);\n\n          case 32:\n            return _context3.abrupt(\"return\", cachedResponse);\n\n          case 33:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[12, 26, 29, 32]]);\n  }));\n\n  return function matchWrapper(_x3) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nvar putWrapper = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref7) {\n    var cacheName, request, response, event, _ref7$plugins, plugins, matchOptions, effectiveRequest, responseToCache, cache, updatePlugins, oldResponse, _iterator4, _step4, plugin;\n\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            cacheName = _ref7.cacheName, request = _ref7.request, response = _ref7.response, event = _ref7.event, _ref7$plugins = _ref7.plugins, plugins = _ref7$plugins === void 0 ? [] : _ref7$plugins, matchOptions = _ref7.matchOptions;\n\n            if (!(process.env.NODE_ENV !== 'production')) {\n              _context4.next = 4;\n              break;\n            }\n\n            if (!(request.method && request.method !== 'GET')) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n              url: getFriendlyURL(request.url),\n              method: request.method\n            });\n\n          case 4:\n            _context4.next = 6;\n            return _getEffectiveRequest({\n              plugins: plugins,\n              request: request,\n              mode: 'write'\n            });\n\n          case 6:\n            effectiveRequest = _context4.sent;\n\n            if (response) {\n              _context4.next = 10;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(effectiveRequest.url), \"'.\"));\n            }\n\n            throw new WorkboxError('cache-put-with-no-response', {\n              url: getFriendlyURL(effectiveRequest.url)\n            });\n\n          case 10:\n            _context4.next = 12;\n            return _isResponseSafeToCache({\n              event: event,\n              plugins: plugins,\n              response: response,\n              request: effectiveRequest\n            });\n\n          case 12:\n            responseToCache = _context4.sent;\n\n            if (responseToCache) {\n              _context4.next = 16;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url), \"' will \") + \"not be cached.\", responseToCache);\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 16:\n            _context4.next = 18;\n            return self.caches.open(cacheName);\n\n          case 18:\n            cache = _context4.sent;\n            updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\"\n            /* CACHE_DID_UPDATE */\n            );\n\n            if (!(updatePlugins.length > 0)) {\n              _context4.next = 26;\n              break;\n            }\n\n            _context4.next = 23;\n            return matchWrapper({\n              cacheName: cacheName,\n              matchOptions: matchOptions,\n              request: effectiveRequest\n            });\n\n          case 23:\n            _context4.t0 = _context4.sent;\n            _context4.next = 27;\n            break;\n\n          case 26:\n            _context4.t0 = null;\n\n          case 27:\n            oldResponse = _context4.t0;\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response for \") + \"\".concat(getFriendlyURL(effectiveRequest.url), \".\"));\n            }\n\n            _context4.prev = 29;\n            _context4.next = 32;\n            return cache.put(effectiveRequest, responseToCache);\n\n          case 32:\n            _context4.next = 40;\n            break;\n\n          case 34:\n            _context4.prev = 34;\n            _context4.t1 = _context4[\"catch\"](29);\n\n            if (!(_context4.t1.name === 'QuotaExceededError')) {\n              _context4.next = 39;\n              break;\n            }\n\n            _context4.next = 39;\n            return executeQuotaErrorCallbacks();\n\n          case 39:\n            throw _context4.t1;\n\n          case 40:\n            _iterator4 = _createForOfIteratorHelper(updatePlugins);\n            _context4.prev = 41;\n\n            _iterator4.s();\n\n          case 43:\n            if ((_step4 = _iterator4.n()).done) {\n              _context4.next = 49;\n              break;\n            }\n\n            plugin = _step4.value;\n            _context4.next = 47;\n            return plugin[\"cacheDidUpdate\"\n            /* CACHE_DID_UPDATE */\n            ].call(plugin, {\n              cacheName: cacheName,\n              event: event,\n              oldResponse: oldResponse,\n              newResponse: responseToCache,\n              request: effectiveRequest\n            });\n\n          case 47:\n            _context4.next = 43;\n            break;\n\n          case 49:\n            _context4.next = 54;\n            break;\n\n          case 51:\n            _context4.prev = 51;\n            _context4.t2 = _context4[\"catch\"](41);\n\n            _iterator4.e(_context4.t2);\n\n          case 54:\n            _context4.prev = 54;\n\n            _iterator4.f();\n\n            return _context4.finish(54);\n\n          case 57:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[29, 34], [41, 51, 54, 57]]);\n  }));\n\n  return function putWrapper(_x4) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n\nexport var cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","url","debug","undefined","matchWrapper","cacheName","matchOptions","self","caches","open","cache","match","cachedResponse","putWrapper","method","error","updatePlugins","length","oldResponse","put","name","newResponse","cacheWrapper"],"sources":["/home/tanishq-singh-2301/hello/node_modules/workbox-core/_private/cacheWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await self.caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await self.caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    const oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}