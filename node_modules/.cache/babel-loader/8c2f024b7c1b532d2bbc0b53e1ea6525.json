{"ast":null,"code":"import _slicedToArray from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _assertThisInitialized from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _classCallCheck from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { matchPath as matchPath$1, withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath, Router as Router$1 } from 'react-router';\n\nvar IonRouteInner = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(IonRouteInner, _React$PureComponent);\n\n  var _super = _createSuper(IonRouteInner);\n\n  function IonRouteInner() {\n    _classCallCheck(this, IonRouteInner);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(IonRouteInner, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(Route, {\n        path: this.props.path,\n        exact: this.props.exact,\n        render: this.props.render,\n\n        /**\n         * `computedMatch` is a private API in react-router v5 that\n         * has been removed in v6.\n         *\n         * This needs to be removed when we support v6.\n         *\n         * TODO: FW-647\n         */\n        computedMatch: this.props.computedMatch\n      });\n    }\n  }]);\n\n  return IonRouteInner;\n}(React.PureComponent);\n\nvar ReactRouterViewStack = /*#__PURE__*/function (_ViewStacks) {\n  _inherits(ReactRouterViewStack, _ViewStacks);\n\n  var _super2 = _createSuper(ReactRouterViewStack);\n\n  function ReactRouterViewStack() {\n    var _this;\n\n    _classCallCheck(this, ReactRouterViewStack);\n\n    _this = _super2.call(this);\n    _this.createViewItem = _this.createViewItem.bind(_assertThisInitialized(_this));\n    _this.findViewItemByRouteInfo = _this.findViewItemByRouteInfo.bind(_assertThisInitialized(_this));\n    _this.findLeavingViewItemByRouteInfo = _this.findLeavingViewItemByRouteInfo.bind(_assertThisInitialized(_this));\n    _this.getChildrenToRender = _this.getChildrenToRender.bind(_assertThisInitialized(_this));\n    _this.findViewItemByPathname = _this.findViewItemByPathname.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ReactRouterViewStack, [{\n    key: \"createViewItem\",\n    value: function createViewItem(outletId, reactElement, routeInfo, page) {\n      var viewItem = {\n        id: generateId('viewItem'),\n        outletId: outletId,\n        ionPageElement: page,\n        reactElement: reactElement,\n        mount: true,\n        ionRoute: false\n      };\n      var matchProps = {\n        exact: reactElement.props.exact,\n        path: reactElement.props.path || reactElement.props.from,\n        component: reactElement.props.component\n      };\n      var match = matchPath(routeInfo.pathname, matchProps);\n\n      if (reactElement.type === IonRoute) {\n        viewItem.ionRoute = true;\n        viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n      }\n\n      viewItem.routeData = {\n        match: match,\n        childProps: reactElement.props\n      };\n      return viewItem;\n    }\n  }, {\n    key: \"getChildrenToRender\",\n    value: function getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n      var _this2 = this;\n\n      var viewItems = this.getViewItemsForOutlet(outletId); // Sync latest routes with viewItems\n\n      React.Children.forEach(ionRouterOutlet.props.children, function (child) {\n        var viewItem = viewItems.find(function (v) {\n          return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);\n        });\n\n        if (viewItem) {\n          viewItem.reactElement = child;\n        }\n      });\n      var children = viewItems.map(function (viewItem) {\n        var clonedChild;\n\n        if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n          clonedChild = React.createElement(ViewLifeCycleManager, {\n            key: \"view-\".concat(viewItem.id),\n            mount: viewItem.mount,\n            removeView: function removeView() {\n              return _this2.remove(viewItem);\n            }\n          }, React.cloneElement(viewItem.reactElement, {\n            computedMatch: viewItem.routeData.match\n          }));\n        } else {\n          var match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);\n          clonedChild = React.createElement(ViewLifeCycleManager, {\n            key: \"view-\".concat(viewItem.id),\n            mount: viewItem.mount,\n            removeView: function removeView() {\n              return _this2.remove(viewItem);\n            }\n          }, React.cloneElement(viewItem.reactElement, {\n            computedMatch: viewItem.routeData.match\n          }));\n\n          if (!match && viewItem.routeData.match) {\n            viewItem.routeData.match = undefined;\n            viewItem.mount = false;\n          }\n        }\n\n        return clonedChild;\n      });\n      return children;\n    }\n  }, {\n    key: \"findViewItemByRouteInfo\",\n    value: function findViewItemByRouteInfo(routeInfo, outletId, updateMatch) {\n      var _this$findViewItemByP = this.findViewItemByPath(routeInfo.pathname, outletId),\n          viewItem = _this$findViewItemByP.viewItem,\n          match = _this$findViewItemByP.match;\n\n      var shouldUpdateMatch = updateMatch === undefined || updateMatch === true;\n\n      if (shouldUpdateMatch && viewItem && match) {\n        viewItem.routeData.match = match;\n      }\n\n      return viewItem;\n    }\n  }, {\n    key: \"findLeavingViewItemByRouteInfo\",\n    value: function findLeavingViewItemByRouteInfo(routeInfo, outletId) {\n      var mustBeIonRoute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      var _this$findViewItemByP2 = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute),\n          viewItem = _this$findViewItemByP2.viewItem;\n\n      return viewItem;\n    }\n  }, {\n    key: \"findViewItemByPathname\",\n    value: function findViewItemByPathname(pathname, outletId) {\n      var _this$findViewItemByP3 = this.findViewItemByPath(pathname, outletId),\n          viewItem = _this$findViewItemByP3.viewItem;\n\n      return viewItem;\n    }\n  }, {\n    key: \"findViewItemByPath\",\n    value: function findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {\n      var viewItem;\n      var match;\n      var viewStack;\n\n      if (outletId) {\n        viewStack = this.getViewItemsForOutlet(outletId);\n        viewStack.some(matchView);\n\n        if (!viewItem) {\n          viewStack.some(matchDefaultRoute);\n        }\n      } else {\n        var viewItems = this.getAllViewItems();\n        viewItems.some(matchView);\n\n        if (!viewItem) {\n          viewItems.some(matchDefaultRoute);\n        }\n      }\n\n      return {\n        viewItem: viewItem,\n        match: match\n      };\n\n      function matchView(v) {\n        if (mustBeIonRoute && !v.ionRoute) {\n          return false;\n        }\n\n        var matchProps = {\n          exact: forceExact ? true : v.routeData.childProps.exact,\n          path: v.routeData.childProps.path || v.routeData.childProps.from,\n          component: v.routeData.childProps.component\n        };\n        var myMatch = matchPath(pathname, matchProps);\n\n        if (myMatch) {\n          viewItem = v;\n          match = myMatch;\n          return true;\n        }\n\n        return false;\n      }\n\n      function matchDefaultRoute(v) {\n        // try to find a route that doesn't have a path or from prop, that will be our default route\n        if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n          match = {\n            path: pathname,\n            url: pathname,\n            isExact: true,\n            params: {}\n          };\n          viewItem = v;\n          return true;\n        }\n\n        return false;\n      }\n    }\n  }]);\n\n  return ReactRouterViewStack;\n}(ViewStacks);\n\nfunction matchComponent$1(node, pathname, forceExact) {\n  var matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  var match = matchPath(pathname, matchProps);\n  return match;\n}\n\nfunction clonePageElement(leavingViewHtml) {\n  var html;\n\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n\n  if (document) {\n    var newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = ''; // Remove an existing back button so the new element doesn't get two of them\n\n    var ionBackButton = newEl.getElementsByTagName('ion-back-button');\n\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n\n    return newEl.firstChild;\n  }\n\n  return undefined;\n}\n\nvar isViewVisible = function isViewVisible(el) {\n  return !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n};\n\nvar StackManager = /*#__PURE__*/function (_React$PureComponent2) {\n  _inherits(StackManager, _React$PureComponent2);\n\n  var _super3 = _createSuper(StackManager);\n\n  function StackManager(props) {\n    var _this3;\n\n    _classCallCheck(this, StackManager);\n\n    _this3 = _super3.call(this, props);\n    _this3.stackContextValue = {\n      registerIonPage: _this3.registerIonPage.bind(_assertThisInitialized(_this3)),\n      isInOutlet: function isInOutlet() {\n        return true;\n      }\n    };\n    _this3.pendingPageTransition = false;\n    _this3.registerIonPage = _this3.registerIonPage.bind(_assertThisInitialized(_this3));\n    _this3.transitionPage = _this3.transitionPage.bind(_assertThisInitialized(_this3));\n    _this3.handlePageTransition = _this3.handlePageTransition.bind(_assertThisInitialized(_this3));\n    _this3.id = generateId('routerOutlet');\n    _this3.prevProps = undefined;\n    _this3.skipTransition = false;\n    return _this3;\n  }\n\n  _createClass(StackManager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.routerOutletElement) {\n        this.setupRouterOutlet(this.routerOutletElement); // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n\n        this.handlePageTransition(this.props.routeInfo);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var pathname = this.props.routeInfo.pathname;\n      var prevPathname = prevProps.routeInfo.pathname;\n\n      if (pathname !== prevPathname) {\n        this.prevProps = prevProps;\n        this.handlePageTransition(this.props.routeInfo);\n      } else if (this.pendingPageTransition) {\n        this.handlePageTransition(this.props.routeInfo);\n        this.pendingPageTransition = false;\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n      this.context.clearOutlet(this.id);\n    }\n  }, {\n    key: \"handlePageTransition\",\n    value: function () {\n      var _handlePageTransition = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(routeInfo) {\n        var _a, _b, enteringViewItem, leavingViewItem, enteringRoute;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!this.routerOutletElement || !this.routerOutletElement.commit)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                /**\n                 * The route outlet has not mounted yet. We need to wait for it to render\n                 * before we can transition the page.\n                 *\n                 * Set a flag to indicate that we should transition the page after\n                 * the component has updated.\n                 */\n                this.pendingPageTransition = true;\n                _context.next = 22;\n                break;\n\n              case 4:\n                enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n                leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n                if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n                  leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n                } // Check if leavingViewItem should be unmounted\n\n\n                if (leavingViewItem) {\n                  if (routeInfo.routeAction === 'replace') {\n                    leavingViewItem.mount = false;\n                  } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n                    if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n                      leavingViewItem.mount = false;\n                    }\n                  } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {\n                    leavingViewItem.mount = false;\n                  }\n                }\n\n                enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n\n                if (enteringViewItem) {\n                  enteringViewItem.reactElement = enteringRoute;\n                } else if (enteringRoute) {\n                  enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n                  this.context.addViewItem(enteringViewItem);\n                }\n\n                if (!(enteringViewItem && enteringViewItem.ionPageElement)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                if (!(enteringViewItem === leavingViewItem)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                if (!(enteringViewItem.routeData.match.url !== routeInfo.pathname)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 14:\n                /**\n                 * If there isn't a leaving view item, but the route info indicates\n                 * that the user has routed from a previous path, then we need\n                 * to find the leaving view item to transition between.\n                 */\n                if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n                  leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n                }\n                /**\n                 * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n                 */\n\n\n                if (!(isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== undefined && !isViewVisible(leavingViewItem.ionPageElement))) {\n                  _context.next = 17;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 17:\n                /**\n                 * The view should only be transitioned in the following cases:\n                 * 1. Performing a replace or pop action, such as a swipe to go back gesture\n                 * to animation the leaving view off the screen.\n                 *\n                 * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n                 * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n                 *\n                 * 3. The entering view is an ion-router-outlet containing a page\n                 * matching the current route and that hasn't already transitioned in.\n                 *\n                 * This should only happen when navigating directly to a nested router outlet\n                 * route or on an initial page load (i.e. refreshing). In cases when loading\n                 * /tabs/tab-1, we need to transition the /tabs page element into the view.\n                 */\n                this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n                _context.next = 21;\n                break;\n\n              case 20:\n                if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n                  // If we have a leavingView but no entering view/route, we are probably leaving to\n                  // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n                  // transition to finish.\n                  // setTimeout(() => {\n                  if (leavingViewItem.ionPageElement) {\n                    leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                    leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                  } // }, 250);\n\n                }\n\n              case 21:\n                this.forceUpdate();\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handlePageTransition(_x) {\n        return _handlePageTransition.apply(this, arguments);\n      }\n\n      return handlePageTransition;\n    }()\n  }, {\n    key: \"registerIonPage\",\n    value: function registerIonPage(page, routeInfo) {\n      var foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n\n      if (foundView) {\n        foundView.ionPageElement = page;\n        foundView.ionRoute = true;\n      }\n\n      this.handlePageTransition(routeInfo);\n    }\n  }, {\n    key: \"setupRouterOutlet\",\n    value: function () {\n      var _setupRouterOutlet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(routerOutlet) {\n        var _this4 = this;\n\n        var canStart, onStart, onEnd;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                canStart = function canStart() {\n                  var config = getConfig();\n                  var swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n\n                  if (!swipeEnabled) {\n                    return false;\n                  }\n\n                  var routeInfo = _this4.props.routeInfo;\n                  var propsToUse = _this4.prevProps && _this4.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? _this4.prevProps.routeInfo : {\n                    pathname: routeInfo.pushedByRoute || ''\n                  };\n\n                  var enteringViewItem = _this4.context.findViewItemByRouteInfo(propsToUse, _this4.id, false);\n\n                  return !!enteringViewItem &&\n                  /**\n                   * The root url '/' is treated as\n                   * the first view item (but is never mounted),\n                   * so we do not want to swipe back to the\n                   * root url.\n                   */\n                  enteringViewItem.mount &&\n                  /**\n                   * When on the first page (whatever view\n                   * you land on after the root url) it\n                   * is possible for findViewItemByRouteInfo to\n                   * return the exact same view you are currently on.\n                   * Make sure that we are not swiping back to the same\n                   * instances of a view.\n                   */\n                  enteringViewItem.routeData.match.path !== routeInfo.pathname;\n                };\n\n                onStart = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                    var routeInfo, propsToUse, enteringViewItem, leavingViewItem;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            routeInfo = _this4.props.routeInfo;\n                            propsToUse = _this4.prevProps && _this4.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? _this4.prevProps.routeInfo : {\n                              pathname: routeInfo.pushedByRoute || ''\n                            };\n                            enteringViewItem = _this4.context.findViewItemByRouteInfo(propsToUse, _this4.id, false);\n                            leavingViewItem = _this4.context.findViewItemByRouteInfo(routeInfo, _this4.id, false);\n                            /**\n                             * When the gesture starts, kick off\n                             * a transition that is controlled\n                             * via a swipe gesture.\n                             */\n\n                            if (!(enteringViewItem && leavingViewItem)) {\n                              _context2.next = 7;\n                              break;\n                            }\n\n                            _context2.next = 7;\n                            return _this4.transitionPage(routeInfo, enteringViewItem, leavingViewItem, 'back', true);\n\n                          case 7:\n                            return _context2.abrupt(\"return\", Promise.resolve());\n\n                          case 8:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n\n                  return function onStart() {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                onEnd = function onEnd(shouldContinue) {\n                  if (shouldContinue) {\n                    _this4.skipTransition = true;\n\n                    _this4.context.goBack();\n                  } else {\n                    /**\n                     * In the event that the swipe\n                     * gesture was aborted, we should\n                     * re-hide the page that was going to enter.\n                     */\n                    var routeInfo = _this4.props.routeInfo;\n                    var propsToUse = _this4.prevProps && _this4.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? _this4.prevProps.routeInfo : {\n                      pathname: routeInfo.pushedByRoute || ''\n                    };\n\n                    var enteringViewItem = _this4.context.findViewItemByRouteInfo(propsToUse, _this4.id, false);\n\n                    var leavingViewItem = _this4.context.findViewItemByRouteInfo(routeInfo, _this4.id, false);\n                    /**\n                     * Ionic React has a design defect where it\n                     * a) Unmounts the leaving view item when using parameterized routes\n                     * b) Considers the current view to be the entering view when using\n                     * parameterized routes\n                     *\n                     * As a result, we should not hide the view item here\n                     * as it will cause the current view to be hidden.\n                     */\n\n\n                    if (enteringViewItem !== leavingViewItem && (enteringViewItem === null || enteringViewItem === void 0 ? void 0 : enteringViewItem.ionPageElement) !== undefined) {\n                      var ionPageElement = enteringViewItem.ionPageElement;\n                      ionPageElement.setAttribute('aria-hidden', 'true');\n                      ionPageElement.classList.add('ion-page-hidden');\n                    }\n                  }\n                };\n\n                routerOutlet.swipeHandler = {\n                  canStart: canStart,\n                  onStart: onStart,\n                  onEnd: onEnd\n                };\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function setupRouterOutlet(_x2) {\n        return _setupRouterOutlet.apply(this, arguments);\n      }\n\n      return setupRouterOutlet;\n    }()\n  }, {\n    key: \"transitionPage\",\n    value: function () {\n      var _transitionPage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(routeInfo, enteringViewItem, leavingViewItem, direction) {\n        var _this5 = this;\n\n        var progressAnimation,\n            runCommit,\n            routerOutlet,\n            routeInfoFallbackDirection,\n            directionToUse,\n            match,\n            newLeavingElement,\n            _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                progressAnimation = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : false;\n\n                runCommit = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(enteringEl, leavingEl) {\n                    var skipTransition;\n                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            skipTransition = _this5.skipTransition;\n                            /**\n                             * If the transition was handled\n                             * via the swipe to go back gesture,\n                             * then we do not want to perform\n                             * another transition.\n                             *\n                             * We skip adding ion-page or ion-page-invisible\n                             * because the entering view already exists in the DOM.\n                             * If we added the classes, there would be a flicker where\n                             * the view would be briefly hidden.\n                             */\n\n                            if (skipTransition) {\n                              /**\n                               * We need to reset skipTransition before\n                               * we call routerOutlet.commit otherwise\n                               * the transition triggered by the swipe\n                               * to go back gesture would reset it. In\n                               * that case you would see a duplicate\n                               * transition triggered by handlePageTransition\n                               * in componentDidUpdate.\n                               */\n                              _this5.skipTransition = false;\n                            } else {\n                              enteringEl.classList.add('ion-page');\n                              enteringEl.classList.add('ion-page-invisible');\n                            }\n\n                            _context4.next = 4;\n                            return routerOutlet.commit(enteringEl, leavingEl, {\n                              deepWait: true,\n                              duration: skipTransition || directionToUse === undefined ? 0 : undefined,\n                              direction: directionToUse,\n                              showGoBack: !!routeInfo.pushedByRoute,\n                              progressAnimation: progressAnimation,\n                              animationBuilder: routeInfo.routeAnimation\n                            });\n\n                          case 4:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function runCommit(_x7, _x8) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                routerOutlet = this.routerOutletElement;\n                routeInfoFallbackDirection = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n                directionToUse = direction !== null && direction !== void 0 ? direction : routeInfoFallbackDirection;\n\n                if (!(enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement)) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                if (!(leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem)) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                // If a page is transitioning to another version of itself\n                // we clone it so we can have an animation to show\n                match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n\n                if (!match) {\n                  _context5.next = 17;\n                  break;\n                }\n\n                newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n\n                if (!newLeavingElement) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                this.routerOutletElement.appendChild(newLeavingElement);\n                _context5.next = 14;\n                return runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n\n              case 14:\n                this.routerOutletElement.removeChild(newLeavingElement);\n\n              case 15:\n                _context5.next = 19;\n                break;\n\n              case 17:\n                _context5.next = 19;\n                return runCommit(enteringViewItem.ionPageElement, undefined);\n\n              case 19:\n                _context5.next = 24;\n                break;\n\n              case 21:\n                _context5.next = 23;\n                return runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n\n              case 23:\n                if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {\n                  leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                  leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                }\n\n              case 24:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function transitionPage(_x3, _x4, _x5, _x6) {\n        return _transitionPage.apply(this, arguments);\n      }\n\n      return transitionPage;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      var children = this.props.children;\n      var ionRouterOutlet = React.Children.only(children);\n      this.ionRouterOutlet = ionRouterOutlet;\n      var components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, function () {\n        _this6.forceUpdate();\n      });\n      return React.createElement(StackContext.Provider, {\n        value: this.stackContextValue\n      }, React.cloneElement(ionRouterOutlet, {\n        ref: function ref(node) {\n          if (ionRouterOutlet.props.setRef) {\n            ionRouterOutlet.props.setRef(node);\n          }\n\n          if (ionRouterOutlet.props.forwardedRef) {\n            ionRouterOutlet.props.forwardedRef.current = node;\n          }\n\n          _this6.routerOutletElement = node;\n          var ref = ionRouterOutlet.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          }\n        }\n      }, components));\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return RouteManagerContext;\n    }\n  }]);\n\n  return StackManager;\n}(React.PureComponent);\n\nfunction matchRoute(node, routeInfo) {\n  var matchedNode;\n  React.Children.forEach(node, function (child) {\n    var matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component\n    };\n    var match = matchPath$1(routeInfo.pathname, matchProps);\n\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  } // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n\n\n  React.Children.forEach(node, function (child) {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n  return matchedNode;\n}\n\nfunction matchComponent(node, pathname, forceExact) {\n  var matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  var match = matchPath$1(pathname, matchProps);\n  return match;\n}\n\nvar IonRouterInner = /*#__PURE__*/function (_React$PureComponent3) {\n  _inherits(IonRouterInner, _React$PureComponent3);\n\n  var _super4 = _createSuper(IonRouterInner);\n\n  function IonRouterInner(props) {\n    var _this7;\n\n    _classCallCheck(this, IonRouterInner);\n\n    _this7 = _super4.call(this, props);\n    _this7.exitViewFromOtherOutletHandlers = [];\n    _this7.locationHistory = new LocationHistory();\n    _this7.viewStack = new ReactRouterViewStack();\n    _this7.routeMangerContextState = {\n      canGoBack: function canGoBack() {\n        return _this7.locationHistory.canGoBack();\n      },\n      clearOutlet: _this7.viewStack.clear,\n      findViewItemByPathname: _this7.viewStack.findViewItemByPathname,\n      getChildrenToRender: _this7.viewStack.getChildrenToRender,\n      goBack: function goBack() {\n        return _this7.handleNavigateBack();\n      },\n      createViewItem: _this7.viewStack.createViewItem,\n      findViewItemByRouteInfo: _this7.viewStack.findViewItemByRouteInfo,\n      findLeavingViewItemByRouteInfo: _this7.viewStack.findLeavingViewItemByRouteInfo,\n      addViewItem: _this7.viewStack.add,\n      unMountViewItem: _this7.viewStack.remove\n    };\n    var routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: _this7.props.location.pathname,\n      search: _this7.props.location.search\n    };\n\n    _this7.locationHistory.add(routeInfo);\n\n    _this7.handleChangeTab = _this7.handleChangeTab.bind(_assertThisInitialized(_this7));\n    _this7.handleResetTab = _this7.handleResetTab.bind(_assertThisInitialized(_this7));\n    _this7.handleNativeBack = _this7.handleNativeBack.bind(_assertThisInitialized(_this7));\n    _this7.handleNavigate = _this7.handleNavigate.bind(_assertThisInitialized(_this7));\n    _this7.handleNavigateBack = _this7.handleNavigateBack.bind(_assertThisInitialized(_this7));\n\n    _this7.props.registerHistoryListener(_this7.handleHistoryChange.bind(_assertThisInitialized(_this7)));\n\n    _this7.handleSetCurrentTab = _this7.handleSetCurrentTab.bind(_assertThisInitialized(_this7));\n    _this7.state = {\n      routeInfo: routeInfo\n    };\n    return _this7;\n  }\n\n  _createClass(IonRouterInner, [{\n    key: \"handleChangeTab\",\n    value: function handleChangeTab(tab, path, routeOptions) {\n      if (!path) {\n        return;\n      }\n\n      var routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n\n      var _path$split = path.split('?'),\n          _path$split2 = _slicedToArray(_path$split, 2),\n          pathname = _path$split2[0],\n          search = _path$split2[1];\n\n      if (routeInfo) {\n        this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), {\n          routeAction: 'push',\n          routeDirection: 'none'\n        });\n\n        if (routeInfo.pathname === pathname) {\n          this.incomingRouteParams.routeOptions = routeOptions;\n          this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n        } else {\n          this.incomingRouteParams.pathname = pathname;\n          this.incomingRouteParams.search = search ? '?' + search : undefined;\n          this.incomingRouteParams.routeOptions = routeOptions;\n          this.props.history.push(pathname + (search ? '?' + search : ''));\n        }\n      } else {\n        this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n      }\n    }\n  }, {\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var _a, _b, _c;\n\n      var leavingLocationInfo;\n\n      if (this.incomingRouteParams) {\n        if (this.incomingRouteParams.routeAction === 'replace') {\n          leavingLocationInfo = this.locationHistory.previous();\n        } else {\n          leavingLocationInfo = this.locationHistory.current();\n        }\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n\n      var leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n\n      if (leavingUrl !== location.pathname) {\n        if (!this.incomingRouteParams) {\n          if (action === 'REPLACE') {\n            this.incomingRouteParams = {\n              routeAction: 'replace',\n              routeDirection: 'none',\n              tab: this.currentTab\n            };\n          }\n\n          if (action === 'POP') {\n            var currentRoute = this.locationHistory.current();\n\n            if (currentRoute && currentRoute.pushedByRoute) {\n              var prevInfo = this.locationHistory.findLastLocation(currentRoute);\n              this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n                routeAction: 'pop',\n                routeDirection: 'back'\n              });\n            } else {\n              this.incomingRouteParams = {\n                routeAction: 'pop',\n                routeDirection: 'none',\n                tab: this.currentTab\n              };\n            }\n          }\n\n          if (!this.incomingRouteParams) {\n            this.incomingRouteParams = {\n              routeAction: 'push',\n              routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n              routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n              tab: this.currentTab\n            };\n          }\n        }\n\n        var routeInfo;\n\n        if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n          routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), {\n            lastPathname: leavingLocationInfo.pathname\n          });\n          this.locationHistory.add(routeInfo);\n        } else {\n          var isPushed = this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n          routeInfo = Object.assign(Object.assign({\n            id: generateId('routeInfo')\n          }, this.incomingRouteParams), {\n            lastPathname: leavingLocationInfo.pathname,\n            pathname: location.pathname,\n            search: location.search,\n            params: this.props.match.params,\n            prevRouteLastPathname: leavingLocationInfo.lastPathname\n          });\n\n          if (isPushed) {\n            routeInfo.tab = leavingLocationInfo.tab;\n            routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n          } else if (routeInfo.routeAction === 'pop') {\n            var r = this.locationHistory.findLastLocation(routeInfo);\n            routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n          } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n            // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n            var lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n            routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n          } else if (routeInfo.routeAction === 'replace') {\n            // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n            var currentRouteInfo = this.locationHistory.current();\n            /**\n             * If going from /home to /child, then replacing from\n             * /child to /home, we don't want the route info to\n             * say that /home was pushed by /home which is not correct.\n             */\n\n            var currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n            var pushedByRoute = currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;\n            routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n            routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n            routeInfo.pushedByRoute = pushedByRoute;\n            routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;\n            routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;\n          }\n\n          this.locationHistory.add(routeInfo);\n        }\n\n        this.setState({\n          routeInfo: routeInfo\n        });\n      }\n\n      this.incomingRouteParams = undefined;\n    }\n    /**\n     * history@4.x uses goBack(), history@5.x uses back()\n     * TODO: If support for React Router <=5 is dropped\n     * this logic is no longer needed. We can just\n     * assume back() is available.\n     */\n\n  }, {\n    key: \"handleNativeBack\",\n    value: function handleNativeBack() {\n      var history = this.props.history;\n      var goBack = history.goBack || history.back;\n      goBack();\n    }\n  }, {\n    key: \"handleNavigate\",\n    value: function handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n      this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n        routeAction: routeAction,\n        routeDirection: routeDirection,\n        routeOptions: routeOptions,\n        routeAnimation: routeAnimation,\n        tab: tab\n      });\n\n      if (routeAction === 'push') {\n        this.props.history.push(path);\n      } else {\n        this.props.history.replace(path);\n      }\n    }\n  }, {\n    key: \"handleNavigateBack\",\n    value: function handleNavigateBack() {\n      var defaultHref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n      var routeAnimation = arguments.length > 1 ? arguments[1] : undefined;\n      var config = getConfig();\n      defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n      var routeInfo = this.locationHistory.current();\n\n      if (routeInfo && routeInfo.pushedByRoute) {\n        var prevInfo = this.locationHistory.findLastLocation(routeInfo);\n\n        if (prevInfo) {\n          this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n            routeAction: 'pop',\n            routeDirection: 'back',\n            routeAnimation: routeAnimation || routeInfo.routeAnimation\n          });\n\n          if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          /**\n           * We need to exclude tab switches/tab\n           * context changes here because tabbed\n           * navigation is not linear, but router.back()\n           * will go back in a linear fashion.\n           */\n          prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '') {\n            /**\n             * history@4.x uses goBack(), history@5.x uses back()\n             * TODO: If support for React Router <=5 is dropped\n             * this logic is no longer needed. We can just\n             * assume back() is available.\n             */\n            var history = this.props.history;\n            var goBack = history.goBack || history.back;\n            goBack();\n          } else {\n            this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n          }\n        } else {\n          this.handleNavigate(defaultHref, 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref, 'pop', 'back');\n      }\n    }\n  }, {\n    key: \"handleResetTab\",\n    value: function handleResetTab(tab, originalHref, originalRouteOptions) {\n      var routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n\n      if (routeInfo) {\n        var newRouteInfo = Object.assign({}, routeInfo);\n        newRouteInfo.pathname = originalHref;\n        newRouteInfo.routeOptions = originalRouteOptions;\n        this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), {\n          routeAction: 'pop',\n          routeDirection: 'back'\n        });\n        this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n      }\n    }\n  }, {\n    key: \"handleSetCurrentTab\",\n    value: function handleSetCurrentTab(tab) {\n      this.currentTab = tab;\n      var ri = Object.assign({}, this.locationHistory.current());\n\n      if (ri.tab !== tab) {\n        ri.tab = tab;\n        this.locationHistory.update(ri);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(RouteManagerContext.Provider, {\n        value: this.routeMangerContextState\n      }, React.createElement(NavManager, {\n        ionRoute: IonRouteInner,\n        ionRedirect: {},\n        stackManager: StackManager,\n        routeInfo: this.state.routeInfo,\n        onNativeBack: this.handleNativeBack,\n        onNavigateBack: this.handleNavigateBack,\n        onNavigate: this.handleNavigate,\n        onSetCurrentTab: this.handleSetCurrentTab,\n        onChangeTab: this.handleChangeTab,\n        onResetTab: this.handleResetTab,\n        locationHistory: this.locationHistory\n      }, this.props.children));\n    }\n  }]);\n\n  return IonRouterInner;\n}(React.PureComponent);\n\nvar IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n\nvar IonReactRouter = /*#__PURE__*/function (_React$Component) {\n  _inherits(IonReactRouter, _React$Component);\n\n  var _super5 = _createSuper(IonReactRouter);\n\n  function IonReactRouter(props) {\n    var _this8;\n\n    _classCallCheck(this, IonReactRouter);\n\n    _this8 = _super5.call(this, props);\n\n    var history = props.history,\n        rest = __rest(props, [\"history\"]);\n\n    _this8.history = history || createBrowserHistory(rest);\n\n    _this8.history.listen(_this8.handleHistoryChange.bind(_assertThisInitialized(_this8)));\n\n    _this8.registerHistoryListener = _this8.registerHistoryListener.bind(_assertThisInitialized(_this8));\n    return _this8;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  _createClass(IonReactRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n      return React.createElement(Router, Object.assign({\n        history: this.history\n      }, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n\n  return IonReactRouter;\n}(React.Component);\n\nvar IonReactMemoryRouter = /*#__PURE__*/function (_React$Component2) {\n  _inherits(IonReactMemoryRouter, _React$Component2);\n\n  var _super6 = _createSuper(IonReactMemoryRouter);\n\n  function IonReactMemoryRouter(props) {\n    var _this9;\n\n    _classCallCheck(this, IonReactMemoryRouter);\n\n    _this9 = _super6.call(this, props);\n    _this9.history = props.history;\n\n    _this9.history.listen(_this9.handleHistoryChange.bind(_assertThisInitialized(_this9)));\n\n    _this9.registerHistoryListener = _this9.registerHistoryListener.bind(_assertThisInitialized(_this9));\n    return _this9;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  _createClass(IonReactMemoryRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n      return React.createElement(Router$1, Object.assign({}, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n\n  return IonReactMemoryRouter;\n}(React.Component);\n\nvar IonReactHashRouter = /*#__PURE__*/function (_React$Component3) {\n  _inherits(IonReactHashRouter, _React$Component3);\n\n  var _super7 = _createSuper(IonReactHashRouter);\n\n  function IonReactHashRouter(props) {\n    var _this10;\n\n    _classCallCheck(this, IonReactHashRouter);\n\n    _this10 = _super7.call(this, props);\n\n    var history = props.history,\n        rest = __rest(props, [\"history\"]);\n\n    _this10.history = history || createHashHistory(rest);\n\n    _this10.history.listen(_this10.handleHistoryChange.bind(_assertThisInitialized(_this10)));\n\n    _this10.registerHistoryListener = _this10.registerHistoryListener.bind(_assertThisInitialized(_this10));\n    return _this10;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  _createClass(IonReactHashRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n      return React.createElement(Router, Object.assign({\n        history: this.history\n      }, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n\n  return IonReactHashRouter;\n}(React.Component);\n\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };","map":{"version":3,"mappings":"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","names":["IonRouteInner","React","Route","path","props","exact","render","computedMatch","PureComponent","ReactRouterViewStack","createViewItem","bind","findViewItemByRouteInfo","findLeavingViewItemByRouteInfo","getChildrenToRender","findViewItemByPathname","outletId","reactElement","routeInfo","page","viewItem","id","generateId","ionPageElement","mount","ionRoute","matchProps","from","component","match","matchPath","pathname","type","IonRoute","disableIonPageManagement","routeData","childProps","ionRouterOutlet","viewItems","getViewItemsForOutlet","Children","forEach","children","child","find","v","matchComponent","map","clonedChild","ViewLifeCycleManager","key","removeView","remove","cloneElement","undefined","updateMatch","findViewItemByPath","shouldUpdateMatch","mustBeIonRoute","lastPathname","forceExact","viewStack","some","matchView","matchDefaultRoute","getAllViewItems","myMatch","url","isExact","params","ViewStacks","node","clonePageElement","leavingViewHtml","html","outerHTML","document","newEl","createElement","innerHTML","style","zIndex","ionBackButton","getElementsByTagName","firstChild","isViewVisible","el","classList","contains","StackManager","registerIonPage","isInOutlet","transitionPage","handlePageTransition","prevProps","skipTransition","routerOutletElement","setupRouterOutlet","prevPathname","pendingPageTransition","context","clearOutlet","commit","enteringViewItem","leavingViewItem","prevRouteLastPathname","routeAction","routeDirection","routeOptions","_a","unmount","enteringRoute","matchRoute","_b","addViewItem","add","setAttribute","forceUpdate","foundView","routerOutlet","canStart","config","getConfig","swipeEnabled","get","mode","propsToUse","pushedByRoute","onStart","Promise","resolve","onEnd","shouldContinue","goBack","swipeHandler","direction","progressAnimation","runCommit","enteringEl","leavingEl","deepWait","duration","directionToUse","showGoBack","animationBuilder","routeAnimation","routeInfoFallbackDirection","newLeavingElement","appendChild","removeChild","only","components","StackContext","Provider","value","stackContextValue","ref","setRef","forwardedRef","current","RouteManagerContext","matchedNode","IonRouterInner","LocationHistory","canGoBack","locationHistory","clear","handleNavigateBack","unMountViewItem","location","search","handleChangeTab","handleResetTab","handleNativeBack","handleNavigate","registerHistoryListener","handleHistoryChange","handleSetCurrentTab","state","tab","getCurrentRouteInfoForTab","split","incomingRouteParams","Object","history","push","action","leavingLocationInfo","previous","leavingUrl","currentTab","currentRoute","prevInfo","findLastLocation","routerOptions","_c","isPushed","r","lastRoute","currentRouteInfo","currentPushedBy","setState","back","assign","replace","defaultHref","originalHref","originalRouteOptions","getFirstRouteInfoForTab","newRouteInfo","ri","update","routeMangerContextState","NavManager","ionRedirect","stackManager","onNativeBack","onNavigateBack","onNavigate","onSetCurrentTab","onChangeTab","onResetTab","IonRouter","withRouter","displayName","IonReactRouter","rest","__rest","createHistory","listen","locationValue","actionValue","historyListenHandler","cb","Router","Component","IonReactMemoryRouter","IonReactHashRouter"],"sources":["/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/IonRouteInner.tsx","/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/ReactRouterViewStack.tsx","/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/clonePageElement.ts","/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/StackManager.tsx","/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/IonRouter.tsx","/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/IonReactRouter.tsx","/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/IonReactMemoryRouter.tsx","/home/tanishq-singh-2301/hello/node_modules/@ionic/react-router/src/ReactRouter/IonReactHashRouter.tsx"],"sourcesContent":["import { IonRouteProps } from '@ionic/react';\nimport React from 'react';\nimport { Route } from 'react-router';\n\nexport class IonRouteInner extends React.PureComponent<IonRouteProps> {\n  render() {\n    return (\n      <Route\n        path={this.props.path}\n        exact={this.props.exact}\n        render={this.props.render}\n        /**\n         * `computedMatch` is a private API in react-router v5 that\n         * has been removed in v6.\n         *\n         * This needs to be removed when we support v6.\n         *\n         * TODO: FW-647\n         */\n        computedMatch={(this.props as any).computedMatch}\n      />\n    );\n  }\n}\n","import {\n  IonRoute,\n  RouteInfo,\n  ViewItem,\n  ViewLifeCycleManager,\n  ViewStacks,\n  generateId,\n} from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router';\n\nexport class ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(\n    outletId: string,\n    reactElement: React.ReactElement,\n    routeInfo: RouteInfo,\n    page?: HTMLElement\n  ) {\n    const viewItem: ViewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false,\n    };\n\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component,\n    };\n\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props,\n    };\n\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId: string, ionRouterOutlet: React.ReactElement, routeInfo: RouteInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, (child: React.ReactElement) => {\n      const viewItem = viewItems.find((v) => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n\n    const children = viewItems.map((viewItem) => {\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, updateMatch?: boolean) {\n    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    const shouldUpdateMatch = updateMatch === undefined || updateMatch === true;\n    if (shouldUpdateMatch && viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, mustBeIonRoute = true) {\n    const { viewItem } = this.findViewItemByPath(\n      routeInfo.lastPathname!,\n      outletId,\n      false,\n      mustBeIonRoute\n    );\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname: string, outletId?: string) {\n    const { viewItem } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  private findViewItemByPath(\n    pathname: string,\n    outletId?: string,\n    forceExact?: boolean,\n    mustBeIonRoute?: boolean\n  ) {\n    let viewItem: ViewItem | undefined;\n    let match: ReturnType<typeof matchPath> | undefined;\n    let viewStack: ViewItem[];\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return { viewItem, match };\n\n    function matchView(v: ViewItem) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component,\n      };\n      const myMatch = matchPath(pathname, matchProps);\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n      return false;\n    }\n\n    function matchDefaultRoute(v: ViewItem) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n  }\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","export function clonePageElement(leavingViewHtml: string | HTMLElement) {\n  let html: string;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild as HTMLElement;\n  }\n  return undefined;\n}\n","import {\n  RouteInfo,\n  RouteManagerContext,\n  StackContext,\n  StackContextState,\n  ViewItem,\n  generateId,\n  getConfig,\n} from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router-dom';\n\nimport { clonePageElement } from './clonePageElement';\n\ninterface StackManagerProps {\n  routeInfo: RouteInfo;\n}\n\ninterface StackManagerState {}\n\nconst isViewVisible = (el: HTMLElement) => !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n\nexport class StackManager extends React.PureComponent<StackManagerProps, StackManagerState> {\n  id: string;\n  context!: React.ContextType<typeof RouteManagerContext>;\n  ionRouterOutlet?: React.ReactElement;\n  routerOutletElement: HTMLIonRouterOutletElement | undefined;\n  prevProps?: StackManagerProps;\n  skipTransition: boolean;\n\n  stackContextValue: StackContextState = {\n    registerIonPage: this.registerIonPage.bind(this),\n    isInOutlet: () => true,\n  };\n\n  private pendingPageTransition = false;\n\n  constructor(props: StackManagerProps) {\n    super(props);\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n    this.prevProps = undefined;\n    this.skipTransition = false;\n  }\n\n  componentDidMount() {\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: StackManagerProps) {\n    const { pathname } = this.props.routeInfo;\n    const { pathname: prevPathname } = prevProps.routeInfo;\n\n    if (pathname !== prevPathname) {\n      this.prevProps = prevProps;\n      this.handlePageTransition(this.props.routeInfo);\n    } else if (this.pendingPageTransition) {\n      this.handlePageTransition(this.props.routeInfo);\n      this.pendingPageTransition = false;\n    }\n  }\n\n  componentWillUnmount() {\n    // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n    this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo: RouteInfo) {\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      /**\n       * The route outlet has not mounted yet. We need to wait for it to render\n       * before we can transition the page.\n       *\n       * Set a flag to indicate that we should transition the page after\n       * the component has updated.\n       */\n      this.pendingPageTransition = true;\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(\n          routeInfo.prevRouteLastPathname,\n          this.id\n        );\n      }\n\n      // Check if leavingViewItem should be unmounted\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if (routeInfo.routeOptions?.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute(\n        this.ionRouterOutlet?.props.children,\n        routeInfo\n      ) as React.ReactElement;\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      } else if (enteringRoute) {\n        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n        this.context.addViewItem(enteringViewItem);\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        /**\n         * If the entering view item is the same as the leaving view item,\n         * then we don't need to transition.\n         */\n        if (enteringViewItem === leavingViewItem) {\n          /**\n           * If the entering view item is the same as the leaving view item,\n           * we are either transitioning using parameterized routes to the same view\n           * or a parent router outlet is re-rendering as a result of React props changing.\n           *\n           * If the route data does not match the current path, the parent router outlet\n           * is attempting to transition and we cancel the operation.\n           */\n          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {\n            return;\n          }\n        }\n\n        /**\n         * If there isn't a leaving view item, but the route info indicates\n         * that the user has routed from a previous path, then we need\n         * to find the leaving view item to transition between.\n         */\n        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n        }\n\n        /**\n         * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n         */\n        if (isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== undefined && !isViewVisible(leavingViewItem.ionPageElement!)) {\n          return;\n        }\n\n        /**\n         * The view should only be transitioned in the following cases:\n         * 1. Performing a replace or pop action, such as a swipe to go back gesture\n         * to animation the leaving view off the screen.\n         *\n         * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n         * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n         *\n         * 3. The entering view is an ion-router-outlet containing a page\n         * matching the current route and that hasn't already transitioned in.\n         *\n         * This should only happen when navigating directly to a nested router outlet\n         * route or on an initial page load (i.e. refreshing). In cases when loading\n         * /tabs/tab-1, we need to transition the /tabs page element into the view.\n         */\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n        // }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page: HTMLElement, routeInfo: RouteInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n    }\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet: HTMLIonRouterOutletElement) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (!swipeEnabled) { return false; }\n\n      const { routeInfo } = this.props;\n\n      const propsToUse = (this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute) ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || '' } as any;\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n\n      return (\n        !!enteringViewItem &&\n        /**\n         * The root url '/' is treated as\n         * the first view item (but is never mounted),\n         * so we do not want to swipe back to the\n         * root url.\n         */\n        enteringViewItem.mount &&\n\n        /**\n         * When on the first page (whatever view\n         * you land on after the root url) it\n         * is possible for findViewItemByRouteInfo to\n         * return the exact same view you are currently on.\n         * Make sure that we are not swiping back to the same\n         * instances of a view.\n         */\n        enteringViewItem.routeData.match.path !== routeInfo.pathname\n      );\n    };\n\n    const onStart = async () => {\n      const { routeInfo } = this.props;\n\n      const propsToUse = (this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute) ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || '' } as any;\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n      /**\n       * When the gesture starts, kick off\n       * a transition that is controlled\n       * via a swipe gesture.\n       */\n      if (enteringViewItem && leavingViewItem) {\n        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, 'back', true);\n      }\n\n      return Promise.resolve();\n    };\n    const onEnd = (shouldContinue: boolean) => {\n      if (shouldContinue) {\n        this.skipTransition = true;\n\n        this.context.goBack();\n      } else {\n        /**\n         * In the event that the swipe\n         * gesture was aborted, we should\n         * re-hide the page that was going to enter.\n         */\n        const { routeInfo } = this.props;\n\n        const propsToUse = (this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute) ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || '' } as any;\n        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n        /**\n         * Ionic React has a design defect where it\n         * a) Unmounts the leaving view item when using parameterized routes\n         * b) Considers the current view to be the entering view when using\n         * parameterized routes\n         *\n         * As a result, we should not hide the view item here\n         * as it will cause the current view to be hidden.\n         */\n        if (\n          enteringViewItem !== leavingViewItem &&\n          enteringViewItem?.ionPageElement !== undefined\n        ) {\n          const { ionPageElement } = enteringViewItem;\n          ionPageElement.setAttribute('aria-hidden', 'true');\n          ionPageElement.classList.add('ion-page-hidden');\n        }\n      }\n    }\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd\n    };\n  }\n\n  async transitionPage(\n    routeInfo: RouteInfo,\n    enteringViewItem: ViewItem,\n    leavingViewItem?: ViewItem,\n    direction?: 'forward' | 'back',\n    progressAnimation = false\n  ) {\n    const runCommit = async (enteringEl: HTMLElement, leavingEl?: HTMLElement) => {\n      const skipTransition = this.skipTransition;\n\n      /**\n       * If the transition was handled\n       * via the swipe to go back gesture,\n       * then we do not want to perform\n       * another transition.\n       *\n       * We skip adding ion-page or ion-page-invisible\n       * because the entering view already exists in the DOM.\n       * If we added the classes, there would be a flicker where\n       * the view would be briefly hidden.\n       */\n      if (skipTransition) {\n        /**\n         * We need to reset skipTransition before\n         * we call routerOutlet.commit otherwise\n         * the transition triggered by the swipe\n         * to go back gesture would reset it. In\n         * that case you would see a duplicate\n         * transition triggered by handlePageTransition\n         * in componentDidUpdate.\n         */\n        this.skipTransition = false;\n      } else {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n      }\n\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: skipTransition || directionToUse === undefined ? 0 : undefined,\n        direction: directionToUse,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation,\n        animationBuilder: routeInfo.routeAnimation,\n      });\n    }\n\n    const routerOutlet = this.routerOutletElement!;\n\n    const routeInfoFallbackDirection =\n      routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root'\n        ? undefined\n        : routeInfo.routeDirection;\n    const directionToUse = direction ?? routeInfoFallbackDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (\n        leavingViewItem &&\n        leavingViewItem.ionPageElement &&\n        enteringViewItem === leavingViewItem\n      ) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem?.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const ionRouterOutlet = React.Children.only(children) as React.ReactElement;\n    this.ionRouterOutlet = ionRouterOutlet;\n\n    const components = this.context.getChildrenToRender(\n      this.id,\n      this.ionRouterOutlet,\n      this.props.routeInfo,\n      () => {\n        this.forceUpdate();\n      }\n    );\n\n    return (\n      <StackContext.Provider value={this.stackContextValue}>\n        {React.cloneElement(\n          ionRouterOutlet as any,\n          {\n            ref: (node: HTMLIonRouterOutletElement) => {\n              if (ionRouterOutlet.props.setRef) {\n                ionRouterOutlet.props.setRef(node);\n              }\n              if (ionRouterOutlet.props.forwardedRef) {\n                ionRouterOutlet.props.forwardedRef.current = node;\n              }\n              this.routerOutletElement = node;\n              const { ref } = ionRouterOutlet as any;\n              if (typeof ref === 'function') {\n                ref(node);\n              }\n            },\n          },\n          components\n        )}\n      </StackContext.Provider>\n    );\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\n\nexport default StackManager;\n\nfunction matchRoute(node: React.ReactNode, routeInfo: RouteInfo) {\n  let matchedNode: React.ReactNode;\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component,\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n\n  return matchedNode;\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","import {\n  AnimationBuilder,\n  LocationHistory,\n  NavManager,\n  RouteAction,\n  RouteInfo,\n  RouteManagerContext,\n  RouteManagerContextState,\n  RouterDirection,\n  ViewItem,\n  generateId,\n  getConfig,\n} from '@ionic/react';\nimport { Action as HistoryAction, Location as HistoryLocation } from 'history';\nimport React from 'react';\nimport { RouteComponentProps, withRouter } from 'react-router-dom';\n\nimport { IonRouteInner } from './IonRouteInner';\nimport { ReactRouterViewStack } from './ReactRouterViewStack';\nimport StackManager from './StackManager';\n\nexport interface LocationState {\n  direction?: RouterDirection;\n  routerOptions?: { as?: string; unmount?: boolean };\n}\n\ninterface IonRouteProps extends RouteComponentProps<{}, {}, LocationState> {\n  registerHistoryListener: (\n    cb: (location: HistoryLocation<any>, action: HistoryAction) => void\n  ) => void;\n}\n\ninterface IonRouteState {\n  routeInfo: RouteInfo;\n}\n\nclass IonRouterInner extends React.PureComponent<IonRouteProps, IonRouteState> {\n  currentTab?: string;\n  exitViewFromOtherOutletHandlers: ((pathname: string) => ViewItem | undefined)[] = [];\n  incomingRouteParams?: Partial<RouteInfo>;\n  locationHistory = new LocationHistory();\n  viewStack = new ReactRouterViewStack();\n  routeMangerContextState: RouteManagerContextState = {\n    canGoBack: () => this.locationHistory.canGoBack(),\n    clearOutlet: this.viewStack.clear,\n    findViewItemByPathname: this.viewStack.findViewItemByPathname,\n    getChildrenToRender: this.viewStack.getChildrenToRender,\n    goBack: () => this.handleNavigateBack(),\n    createViewItem: this.viewStack.createViewItem,\n    findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n    addViewItem: this.viewStack.add,\n    unMountViewItem: this.viewStack.remove,\n  };\n\n  constructor(props: IonRouteProps) {\n    super(props);\n\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search,\n    };\n\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n\n    this.state = {\n      routeInfo,\n    };\n  }\n\n  handleChangeTab(tab: string, path?: string, routeOptions?: any) {\n    if (!path) { return; }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = { ...routeInfo, routeAction: 'push', routeDirection: 'none' };\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location: HistoryLocation<LocationState>, action: HistoryAction) {\n    let leavingLocationInfo: RouteInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab, // TODO this isn't legit if replacing to a page that is not in the tabs\n          };\n        }\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back' };\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab,\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: location.state?.direction || 'forward',\n            routeOptions: location.state?.routerOptions,\n            tab: this.currentTab,\n          };\n        }\n      }\n\n      let routeInfo: RouteInfo;\n\n      if (this.incomingRouteParams?.id) {\n        routeInfo = {\n          ...(this.incomingRouteParams as RouteInfo),\n          lastPathname: leavingLocationInfo.pathname,\n        };\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed =\n          this.incomingRouteParams.routeAction === 'push' &&\n          this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = {\n          id: generateId('routeInfo'),\n          ...this.incomingRouteParams,\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname,\n        };\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo?.pushedByRoute;\n          const pushedByRoute = (currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname) ? currentPushedBy : routeInfo.pushedByRoute;\n\n          routeInfo.lastPathname = currentRouteInfo?.pathname || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo?.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          routeInfo.routeDirection = currentRouteInfo?.routeDirection || routeInfo.routeDirection;\n          routeInfo.routeAnimation = currentRouteInfo?.routeAnimation || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo,\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n  handleNativeBack() {\n    const history = this.props.history as any;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(\n    path: string,\n    routeAction: RouteAction,\n    routeDirection?: RouterDirection,\n    routeAnimation?: AnimationBuilder,\n    routeOptions?: any,\n    tab?: string\n  ) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab,\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref: string | RouteInfo = '/', routeAnimation?: AnimationBuilder) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref' as any);\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        this.incomingRouteParams = {\n          ...prevInfo,\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: routeAnimation || routeInfo.routeAnimation,\n        };\n        if (\n          routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          (\n            /**\n             * We need to exclude tab switches/tab\n             * context changes here because tabbed\n             * navigation is not linear, but router.back()\n             * will go back in a linear fashion.\n             */\n            prevInfo.pathname === routeInfo.pushedByRoute &&\n            routeInfo.tab === '' && prevInfo.tab === ''\n          )\n        ) {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history as any;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref as string, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref as string, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab: string, originalHref: string, originalRouteOptions: any) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = { ...routeInfo };\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = { ...newRouteInfo, routeAction: 'pop', routeDirection: 'back' };\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab: string) {\n    this.currentTab = tab;\n    const ri = { ...this.locationHistory.current() };\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return (\n      <RouteManagerContext.Provider value={this.routeMangerContextState}>\n        <NavManager\n          ionRoute={IonRouteInner}\n          ionRedirect={{}}\n          stackManager={StackManager}\n          routeInfo={this.state.routeInfo!}\n          onNativeBack={this.handleNativeBack}\n          onNavigateBack={this.handleNavigateBack}\n          onNavigate={this.handleNavigate}\n          onSetCurrentTab={this.handleSetCurrentTab}\n          onChangeTab={this.handleChangeTab}\n          onResetTab={this.handleResetTab}\n          locationHistory={this.locationHistory}\n        >\n          {this.props.children}\n        </NavManager>\n      </RouteManagerContext.Provider>\n    );\n  }\n}\n\nexport const IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n","import {\n  Action as HistoryAction,\n  History,\n  Location as HistoryLocation,\n  createBrowserHistory as createHistory,\n} from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactRouter extends React.Component<IonReactRouterProps> {\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n  history: History;\n\n  constructor(props: IonReactRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n /**\n  * history@4.x passes separate location and action\n  * params. history@5.x passes location and action\n  * together as a single object.\n  * TODO: If support for React Router <=5 is dropped\n  * this logic is no longer needed. We can just assume\n  * a single object with both location and action.\n  */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n   const locationValue = (location as any).location || location;\n   const actionValue = (location as any).action || action;\n   if (this.historyListenHandler) {\n     this.historyListenHandler(locationValue, actionValue);\n   }\n }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import { Action as HistoryAction, Location as HistoryLocation, MemoryHistory } from 'history';\nimport React from 'react';\nimport { MemoryRouterProps, Router } from 'react-router';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactMemoryRouterProps extends MemoryRouterProps {\n  history: MemoryHistory;\n}\n\nexport class IonReactMemoryRouter extends React.Component<IonReactMemoryRouterProps> {\n  history: MemoryHistory;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactMemoryRouterProps) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import {\n  Action as HistoryAction,\n  History,\n  Location as HistoryLocation,\n  createHashHistory as createHistory,\n} from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactHashRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactHashRouter extends React.Component<IonReactHashRouterProps> {\n  history: History;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactHashRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}