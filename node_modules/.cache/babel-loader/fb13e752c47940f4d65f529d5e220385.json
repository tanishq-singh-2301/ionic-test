{"ast":null,"code":"import _regeneratorRuntime from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/tanishq-singh-2301/hello/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers.js';\nimport { b as printRequiredElementError } from './index7.js';\nvar ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nvar ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nvar ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\n\nvar ION_CONTENT_SELECTOR = \"\".concat(ION_CONTENT_ELEMENT_SELECTOR, \", \").concat(ION_CONTENT_CLASS_SELECTOR);\n\nvar isIonContent = function isIonContent(el) {\n  return el && el.tagName === ION_CONTENT_TAG_NAME;\n};\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\n\n\nvar getScrollElement = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(el) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!isIonContent(el)) {\n              _context.next = 4;\n              break;\n            }\n\n            _context.next = 3;\n            return new Promise(function (resolve) {\n              return componentOnReady(el, resolve);\n            });\n\n          case 3:\n            return _context.abrupt(\"return\", el.getScrollElement());\n\n          case 4:\n            return _context.abrupt(\"return\", el);\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getScrollElement(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\n\n\nvar findIonContent = function findIonContent(el) {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  var customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n\n  if (customContentHost) {\n    return customContentHost;\n  }\n\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\n\n\nvar findClosestIonContent = function findClosestIonContent(el) {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\n\n\nvar scrollToTop = function scrollToTop(el, durationMs) {\n  if (isIonContent(el)) {\n    var content = el;\n    return content.scrollToTop(durationMs);\n  }\n\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto'\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\n\n\nvar scrollByPoint = function scrollByPoint(el, x, y, durationMs) {\n  if (isIonContent(el)) {\n    var content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto'\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\n\n\nvar printIonContentErrorMsg = function printIonContentErrorMsg(el) {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n/**\n * Several components in Ionic need to prevent scrolling\n * during a gesture (card modal, range, item sliding, etc).\n * Use this utility to account for ion-content and custom content hosts.\n */\n\n\nvar disableContentScrollY = function disableContentScrollY(contentEl) {\n  if (isIonContent(contentEl)) {\n    var ionContent = contentEl;\n    var initialScrollY = ionContent.scrollY;\n    ionContent.scrollY = false;\n    /**\n     * This should be passed into resetContentScrollY\n     * so that we can revert ion-content's scrollY to the\n     * correct state. For example, if scrollY = false\n     * initially, we do not want to enable scrolling\n     * when we call resetContentScrollY.\n     */\n\n    return initialScrollY;\n  } else {\n    contentEl.style.setProperty('overflow', 'hidden');\n    return true;\n  }\n};\n\nvar resetContentScrollY = function resetContentScrollY(contentEl, initialScrollY) {\n  if (isIonContent(contentEl)) {\n    contentEl.scrollY = initialScrollY;\n  } else {\n    contentEl.style.removeProperty('overflow');\n  }\n};\n\nexport { ION_CONTENT_ELEMENT_SELECTOR as I, findClosestIonContent as a, ION_CONTENT_CLASS_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };","map":{"version":3,"names":["c","componentOnReady","b","printRequiredElementError","ION_CONTENT_TAG_NAME","ION_CONTENT_ELEMENT_SELECTOR","ION_CONTENT_CLASS_SELECTOR","ION_CONTENT_SELECTOR","isIonContent","el","tagName","getScrollElement","Promise","resolve","findIonContent","customContentHost","querySelector","findClosestIonContent","closest","scrollToTop","durationMs","content","scrollTo","top","left","behavior","scrollByPoint","x","y","scrollBy","printIonContentErrorMsg","disableContentScrollY","contentEl","ionContent","initialScrollY","scrollY","style","setProperty","resetContentScrollY","removeProperty","I","a","d","f","g","i","p","r","s"],"sources":["/home/tanishq-singh-2301/hello/node_modules/@ionic/core/components/index8.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers.js';\nimport { b as printRequiredElementError } from './index7.js';\n\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\nconst isIonContent = (el) => el && el.tagName === ION_CONTENT_TAG_NAME;\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\nconst getScrollElement = async (el) => {\n  if (isIonContent(el)) {\n    await new Promise((resolve) => componentOnReady(el, resolve));\n    return el.getScrollElement();\n  }\n  return el;\n};\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\nconst findIonContent = (el) => {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n  if (customContentHost) {\n    return customContentHost;\n  }\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\nconst findClosestIonContent = (el) => {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\nconst scrollToTop = (el, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollToTop(durationMs);\n  }\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\nconst scrollByPoint = (el, x, y, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\nconst printIonContentErrorMsg = (el) => {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n/**\n * Several components in Ionic need to prevent scrolling\n * during a gesture (card modal, range, item sliding, etc).\n * Use this utility to account for ion-content and custom content hosts.\n */\nconst disableContentScrollY = (contentEl) => {\n  if (isIonContent(contentEl)) {\n    const ionContent = contentEl;\n    const initialScrollY = ionContent.scrollY;\n    ionContent.scrollY = false;\n    /**\n     * This should be passed into resetContentScrollY\n     * so that we can revert ion-content's scrollY to the\n     * correct state. For example, if scrollY = false\n     * initially, we do not want to enable scrolling\n     * when we call resetContentScrollY.\n     */\n    return initialScrollY;\n  }\n  else {\n    contentEl.style.setProperty('overflow', 'hidden');\n    return true;\n  }\n};\nconst resetContentScrollY = (contentEl, initialScrollY) => {\n  if (isIonContent(contentEl)) {\n    contentEl.scrollY = initialScrollY;\n  }\n  else {\n    contentEl.style.removeProperty('overflow');\n  }\n};\n\nexport { ION_CONTENT_ELEMENT_SELECTOR as I, findClosestIonContent as a, ION_CONTENT_CLASS_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}